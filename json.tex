\chapter{User-Defined Directives}\label{chap:json}

%XevXML is a framework for user-defined code transformations. 

In XevXML, transformation rules are defined by XSLT rules, and applied
to an XML AST. By writing appropriate XSLT rules, XevXML as well as
compilers can transform an AST in various ways.  However, directly
transforming an AST might be a too low-level approach for performance
optimizations on a case-by-case basis.  Therefore, several high-level
interfaces for XevXML are under development.

In practice, code modifications for performance optimizations are often
expressed by combinations of well-known loop transformations.  Moreover,
text insertion and deletion based on code pattern matching are also
frequently required for practical performance optimizations.
Nonetheless, it is not very easy to correctly define their XSLT rules
manually.

In this chapter, a high-level interface for user-defined code
transformations is described. The interface is designed only for some
specific purposes.  Although the interface is less flexible than the
XSLT approach of straightforwardly dictating AST transformations, it
offers an easy way to quickly define a custom compiler directive that is
associated with a composite of predefined rules. Such a directive can
also be associated with text insertion and deletion. Therefore, the
high-level interface is useful for generating a lot of transformation
rules and also for mechanically inserting some texts into a code, which
are frequently required in practical performance optimizations.

\section{XSLT rule generation}
XevXML provides the \texttt{xsltgen} command that reads a simple
JSON\cite{json} file to generate XSLT rules, each of which is associated
with one user-defined compiler directive.  An XSLT rule generated by
\texttt{xsltgen} is either a composite of predefined XSLT rules or text
insertion/deletion.  Although \texttt{xsltgen} is available only for
these purposes, it provides a much easier way to define a custom
compiler directive associated with such a rule.

\begin{framed}
\begin{description}
 \item[NAME]~\\
	    \texttt{xsltgen} -- XSLT rule generator

 \item[SYNOPSIS]~\\
	    \texttt{xsltgen [OPTIONS] }

 \item[DESCRIPTION]~\\ \texttt{xsltgen} converts a configuration file in
	    JSON to an XSLT file of code transformation rules.
	    \texttt{xsltgen} reads a JSON file from the standard input,
	    and prints a XSLT file to the standard
	    output. 

 \item[EXAMPLES]~\\ \texttt{xsltgen $<$ config.json $>$ rules.xsl}\\ This command
	    will read \texttt{test.json} and write XSLT rules to \texttt{rules.xsl}.
\end{description}
\end{framed}

An example of a JSON file is as follows.
\begin{framed}
\begin{src}
{
  "xev loop_tag1":{
    "target":"SgIfStmt",
    "insert-before":"!$test"
  }
  "xev loop_tag2":{
    "target":"SgFortranDo",
    "rules":[
      {"chill_unroll_jam":{"var":"k","max":4}},
      {"chill_unroll":{"var":"i","max":2}}
    ]
  }
}
\end{src}
\end{framed}

A JSON object enclosed in \texttt{\{} and \texttt{\}} is an unordered
collection of any values. The root object whose \texttt{\{} is in the
first line contains two pairs of keys and values that are directive
definitions.  Notice that the colon character, \texttt{:}, is used to
separate a key and its value. In a directive definition, the key
indicates the directive name, and its value is a JSON object, called a
rule definition, that defines the rule associated with the directive.
In the above file, two compiler directives, \texttt{xev loop\_tag1} and
\texttt{xev loop\_tag2}, are defined for Fortran. If the key is
\texttt{"*"}, the rule defined by its value is applied without any
directive. The pair whose key is \texttt{"target"} specifies what kind
of statements the rule is applied. That is, the value is expected to be
the AST node name of the statement that appears after the directive.

The first directive, \texttt{xev loop\_tag1}, assumes that it is
followed by an \texttt{IF} statement. Then, it simply inserts a comment
before the IF statement.

The second directive, \texttt{xev loop\_tag2}, is associated with a
composite of two predefined rules, \texttt{chill\_unroll\_jam} and
\texttt{chill\_unroll}.  This directive applies those loop optimization
rules with the given parameters to the \texttt{DO} statement following
the directive, which is an XML element of \texttt{SgFortranDo}.  The
predefined rules with their parameters are listed in an array of JSON,
which is enclosed in \texttt{[} and \texttt{]}. Unlike an object of
JSON, an array is an ordered list. The rules are applied in the same
order as they appear in the array.

\section{Loop optimization}
The most time-consuming part of a scientific application is usually
written as a loop, a so-called kernel loop.  Thus, loop optimization is
a key to improve the performance of such an application.  There are a
lot of loop optimization techniques, and most of them are supposed to be
done by compilers. Typical loop optimization techniques are as follows.
\begin{itemize}
 \item Loop unrolling
 \item Loop tiling
 \item Loop interchange
 \item Loop permutation
 \item Loop collapse
 \item Loop fusion
 \item Loop fission~(aka. loop distribution)
 \item Unroll and jam~(aka. outer loop unrolling)
\end{itemize}

In some cases, compilers are unable to perfectly apply those techniques
to a kernel loop for various reasons.  In such a case, manual
optimizations of the kernel loop might be required to achieve high
performance. However, even if the optimization is a certain combination
of the techniques listed above, manual optimization of a kernel loop is
not an easy task. This is because an appropriate combination of loop
optimization techniques is unknown. In addition, most of loop
optimization techniques have some parameters that need to be determined
appropriately for high performance.

To make matters worse, different platforms require different loop
optimizations.  Appropriate loop optimization, i.e.,~the combination and
parameters, could change drastically depending on the platform.  Thus,
manual code modification for loop optimization generally results in
specializing the code only for a particular platform. Accordingly, the
necessary information for loop optimizations should be separated from an
application code.

Because of the importance, XevXML provides the \texttt{xsltgen} command
as an easy way to compose loop optimization techniques and to associate
the composite with a user-defined compiler directive.  Code
transformation rules for basic loop optimization techniques are
predefined. The predefined rules in the XevXML transformation rule
library are listed as follows.

\textbf{*** List of predefined rules and their parameters***}

Those predefined rules are themselves written in XSLT, and hence
customizable for special demands of individual cases. A custozmied rule
can also be used together with other predefined rules using the
\texttt{xsltgen} command. Chapter~\ref{chap:xslt} describes how to
customize predefined rules and also how to define new rules.

%One difficuelty in manual loop optimizations is that an appropriate
%combination of loop optimization techniques and their appropriate
%parameters are unknown.

\section{Text insertion/deletion}
The \texttt{xsltgen} command can also be used to define a custom
compiler directive for inserting or deleting a text into a code. Such a
directive is useful to literally change some statements depending on the
target platform.  Although the C preprocessor can also achieve it using
\texttt{\#ifdef}, such an approach often makes an application code
unmaintainable, so-called \texttt{\#ifdef} hell. In the case of using
\texttt{xsltgen}, the text to be inserted is written in an exterenal
file, which is an XSLT file generated by \texttt{xsltgen}.  Therefore,
the original code is not messed up with platform-dependent code
fragments.

To define a directive for text insertion, an JSON object of the
directive definition has one or more pairs whose keys are
\texttt{"insert-before"}, \texttt{"insert-after"}, or \texttt{"replace"}
and whose values are strings. As the names imply,
\texttt{"insert-before"}, \texttt{"insert-after"}, and
\texttt{"replace"} inserts a text before the target statement, inserts a
text after the target statement, and replace the target statement with a
text, respectively.  

For example, the following JSON file will produce an XML rule that
inserts the function calls before and after a \texttt{for} loop.
\begin{framed}
\begin{src}
{
  "*":{
    "target":"SgForStatement",
    "insert-before":"startLoop();",
    "insert-after":"endLoop();"
  }
}
\end{src}
\end{framed}
In the above directive definition, the directive name is \texttt{*}. The
rule does not need any directive in the code, and is applied to every
\texttt{for} statement. More specifically, the rule is applied to the
AST subtree whose root is \texttt{SgForStatement}. Therefore, the
function call of \texttt{endLoop();} is inserted right after the loop
body of every \texttt{for} loop.

If a pair of \texttt{"replace"} and an empty string is given in the
directive definition, the directive will simply remove the target
statement. Namely, such a directive can be used to remove the statement
for a particular platform.


\section{Summary}
The \texttt{xsltgen} command and its configuration file are now under
active development. Although it is currently used only for some specific
purposes, it offers a very easy way to define a user-defined code
transformation associated with a custom directive. Therefore, it will be
further extended to allow users to quickly define various kinds of code
transformations.
